args <- commandArgs(trailingOnly = TRUE)
# the first input parameter needs to be the directory for metagenomics with all the result subdirectories
# the second input parameter needs to be the directory for metatranscriptomics with all the result subdirectories
# the third input parameter needs to be the directory where the results will be saved and the subdirectories created - needs to exist

# assumes a specific directory structure generated by default by the earlier scripts

# e.g.
# args <- character(3)
# args[1] <- "/scratch/project_2009164/2_OULANKA/Tommi/final/metagenomics"
# args[2] <- "/scratch/project_2009164/2_OULANKA/Tommi/final/metatranscriptomics"
# args[3] <- "/scratch/project_2009164/2_OULANKA/Tommi/final/downstream/lmm_analysis"

# a script to perform linead mixed effects model (LMM) analysis for the phyloflash taxonomic datasets

# load libraries
library(lmerTest)
library(microbiome)

# define custom functions
# calculate false discovery rates for a data.frame of p-values
getFDRdataframe <- function(sig_vals){
  sig_mat <- as.matrix(sig_vals)
  sig_vec <- as.vector(sig_mat)
  sig_vec <- as.numeric(sig_vec)
  fdrs_vec <- p.adjust(p = sig_vec, method = "fdr")
  fdrs_mat <- matrix(fdrs_vec, ncol=ncol(sig_mat))
  fdr_vals <- data.frame(fdrs_mat, stringsAsFactors = F, check.names = F)
  colnames(fdr_vals) <- colnames(sig_vals)
  rownames(fdr_vals) <- rownames(sig_vals)
  return(fdr_vals)
}

# load metagenomics data
setwd(as.character(args[1]))
setwd("phyloflash")
setwd("downstream")
load("Otu_Tax_Tables_Parsed_Filtered.RData")

# here we have compositional data already aggregated to the order and phylum levels
psq_order_mg <- psq_order
psq_phylum_mg  <- psq_phylum

# load metatranscriptomics data
setwd(as.character(args[2]))
setwd("phyloflash")
setwd("downstream")
load("Otu_Tax_Tables_Parsed_Filtered.RData")

# here we have compositional data already aggregated to the order and phylum levels
psq_order_mt <- psq_order
psq_phylum_mt  <- psq_phylum

# get compositional data sets
data_order_mg <- data.frame(otu_table(psq_order_mg), stringsAsFactors = F, check.names = F)
data_order_mt <- data.frame(otu_table(psq_order_mt), stringsAsFactors = F, check.names = F)
data_phylum_mg <- data.frame(otu_table(psq_phylum_mg), stringsAsFactors = F, check.names = F)
data_phylum_mt <- data.frame(otu_table(psq_phylum_mt), stringsAsFactors = F, check.names = F)

# put into list
datas_list <- list(data_order_mg, data_phylum_mg, data_order_mt, data_phylum_mt)
names(datas_list) <- c("order_mg", "phylum_mg", "order_mt", "phylum_mt")

psq_list <- list(psq_order_mg, psq_phylum_mg, psq_order_mt, psq_phylum_mt)
names(psq_list) <- c("order_mg", "phylum_mg", "order_mt", "phylum_mt")

# clr transform
psq_clr_list <- list()
datas_clr <- list()

for(i in 1:length(psq_list)){
  temp_psq <- psq_list[[i]]
  temp_psq <-  microbiome::transform(x = temp_psq, transform = "clr")
  
  psq_clr_list[[i]] <- temp_psq
  datas_clr[[i]] <- data.frame(otu_table(temp_psq), stringsAsFactors = F, check.names = F)
}
names(psq_clr_list) <- names(datas_clr) <- names(datas_list)

# pick the relevant metadata
meta_use <- metadata[,c("Grazing","Treatment","Veg_clusters")]
colnames(meta_use) <- c("grazing", "treatment", "veg_clusters")

# set levels for metadata
meta_use$grazing <- factor(meta_use$grazing, levels = c("ungrazed", "grazed"))
meta_use$treatment <- factor(meta_use$treatment, levels = c("CTL", "+S", "-S"))
meta_use$veg_clusters <- factor(meta_use$veg_clusters, levels = c("t_ces", "c_cho", "c_ros"))

# set working directory to the results directory
setwd(as.character(args[3]))
keep_items <- ls()
keep_items <- c(keep_items, "keep_items")

for(i in 1:length(datas_clr)){
  
  print(paste("Processing data:", names(datas_list)[i]))
  
  # pick the relevant data
  data <- datas_clr[[i]]
  
  # remove other - we don't want to test for that - not informative
  unkn_loc <- grep("unknown|Other", rownames(data))
  if(length(unkn_loc)>0){data <- data[-unkn_loc,]}
  
  # save the values for the simple models here
  sig_values_lmm_simple <- coefficients_lmm_simple <- data.frame(matrix(nrow = nrow(data), ncol = 3))
  
  # save the values for the best fitting models here
  sig_values_lmm_best <- coefficients_lmm_best <- data.frame(matrix(nrow = nrow(data), ncol = 6))
  
  # save the models also
  lmm_models_simple <- list()
  lmm_models_complex <- list()
  
  for(k in 1:nrow(data)){
    
    # make a data frame
    temp_data <- cbind(as.numeric(data[k,]), meta_use)
    colnames(temp_data)[1] <- "expression"
    
    # build the simpler model - no interactions
    set.seed(1)
    mod_lmm_simple <- lmer(expression ~ grazing + treatment + (1|veg_clusters), REML=FALSE, data = temp_data)
    
    # build the more complex model including interactions
    set.seed(1)
    mod_lmm_complex <- lmer(expression ~ grazing*treatment + (1|veg_clusters), REML=FALSE, data = temp_data)
    
    # get the coefficients
    sum_lmm_simple <- summary(mod_lmm_simple)$coefficients
    sum_lmm_complex <- summary(mod_lmm_complex)$coefficients
    
    # perform Likelihood Ratio Test (LRT)
    # concept: The LRT compares the likelihoods of the two models. It's based on the idea that if the 
    # interaction term significantly improves the model's fit, the model with the interaction should 
    # have a much higher likelihood.
    model_comparison <- anova(mod_lmm_simple, mod_lmm_complex)
    
    # extract significance value
    model_comparison_sig <- model_comparison$`Pr(>Chisq)`[2]
    
    # save the signficance values for the simple model
    sig_values_lmm_simple[k,] <- sum_lmm_simple[-1,5]
    coefficients_lmm_simple[k,] <- sum_lmm_simple[-1,1]
    
    # save the significance values for the best model
    if(model_comparison_sig<0.05){
      sig_values_lmm_best[k,1:5] <- sum_lmm_complex[-1,5]
      sig_values_lmm_best[k,6] <- "interaction"
      
      coefficients_lmm_best[k,1:5] <- sum_lmm_complex[-1,1]
      coefficients_lmm_best[k,6] <- "interaction"
    }else{
      sig_values_lmm_best[k,1:3] <- sum_lmm_simple[-1,5]
      sig_values_lmm_best[k,6] <- "simple"
      
      coefficients_lmm_best[k,1:3] <- sum_lmm_simple[-1,1]
      coefficients_lmm_best[k,6] <- "simple"
    }
    
    # save the models
    lmm_models_simple[[k]] <- mod_lmm_simple
    lmm_models_complex[[k]] <- mod_lmm_complex
    
    # clean 
    rm(temp_data)
    rm(mod_lmm_simple)
    rm(mod_lmm_complex)
    rm(sum_lmm_simple)
    rm(sum_lmm_complex)
    rm(model_comparison)
    rm(model_comparison_sig)
  }
  
  # set names
  names(lmm_models_simple) <- names(lmm_models_complex) <- rownames(sig_values_lmm_simple) <- rownames(coefficients_lmm_simple) <- rownames(sig_values_lmm_best) <- rownames(coefficients_lmm_best) <- rownames(data)
  colnames(sig_values_lmm_best)[1:5] <- colnames(coefficients_lmm_best)[1:5] <- rownames(summary(lmm_models_complex[[1]])$coefficients)[-1]
  colnames(sig_values_lmm_best)[6] <- colnames(coefficients_lmm_best)[6] <- "best_model"
  colnames(sig_values_lmm_simple) <- colnames(coefficients_lmm_simple) <- rownames(summary(lmm_models_simple[[1]])$coefficients)[-1]
  
  # calculate fdr
  # strict - over all comparisons simultaneously
  fdr_strict_simple <- getFDRdataframe(sig_values_lmm_simple)
  fdr_strict_best <- getFDRdataframe(sig_values_lmm_best[,c(1:5)])
  fdr_strict_best$best_model <- sig_values_lmm_best$best_model
  
  # save everything
  ses_info <- sessionInfo()
  save_items <- ls()
  save_items <- save_items[-which(save_items%in%keep_items)]
  
  dir.create(names(datas_list)[i])
  setwd(names(datas_list)[i])
  save(list = save_items, file = "lmm_analysis_done.RData")
  setwd("../")
  
  # clean
  save_items <- c(save_items, "save_items")
  rm(list = save_items)
  
  print("Data processed.")
  print("***************************************************************")
  
}

# print out session info
print("SessionInfo:")
sessionInfo()